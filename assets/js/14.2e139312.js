(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{508:function(t,s,a){t.exports=a.p+"assets/img/1.f78af323.jpg"},534:function(t,s,a){"use strict";a.r(s);var e=a(2),v=Object(e.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("RanLan"),t._v(" "),e("h2",{attrs:{id:"什么是-js-异步模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-js-异步模式"}},[t._v("#")]),t._v(" 什么是 JS 异步模式")]),t._v(" "),e("p",[t._v("JS 异步模式不会等待任务执行完再进入下一个任务，它会在任务开启后立即进入下一个任务的执行。该异步任务的后续逻辑处理一般会通过回调的方式来执行。")]),t._v(" "),e("h2",{attrs:{id:"异步模式处理逻辑-event-loop-事件轮询"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#异步模式处理逻辑-event-loop-事件轮询"}},[t._v("#")]),t._v(" 异步模式处理逻辑 —— Event Loop（事件轮询）")]),t._v(" "),e("p",[t._v("代码开始执行，加载代码后进入调用栈。同步任务顺次执行。某一个时刻 JS 发起一个异步调用，异步线程执行异步任务后将异步回调放入 "),e("code",[t._v("Event Loop")]),t._v(" 的消息队列等待执行。JS 线程在完成同步任务后依次执行消息队列中的任务。")]),t._v(" "),e("p",[t._v("这里需要注意，JS 是同步执行的，这一点毋庸置疑。之所以会有异步模式，这是由那些具有异步模式的 API 造成的，而这些 API 在运行环境中其实是有其自己的线程的，这也说明了为什么它们不会阻塞 JS 的同步执行。然后它们执行完之后，会把回调放入"),e("code",[t._v("Event Loop")]),t._v(" 的消息队列等待执行。执行这些回调的时候，其实又回到了 JS 线程，所以它们会等到前一轮的同步任务执行完毕之后再执行。")]),t._v(" "),e("p",[e("img",{attrs:{src:a(508),alt:"事件轮询"}})]),t._v(" "),e("h2",{attrs:{id:"js-实现异步的基石-回调函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js-实现异步的基石-回调函数"}},[t._v("#")]),t._v(" JS 实现异步的基石 —— 回调函数")]),t._v(" "),e("p",[t._v("回调函数是由调用者定义，由执行者执行的函数。")]),t._v(" "),e("p",[t._v("举例说明：我让小明给我去买一包烟，等他买烟回来我就给他一份跑腿费。这里，我作为调用者定义了一个回调函数，给一份跑腿费，小明作为执行者，去买了一包烟，这时候回调前提达成，就可以执行拿跑腿费这件事了。回调函数作为异步的基石是因为小明在给我买烟的这段时间，我可以去做别的事情，不会阻塞我。")])],1)}),[],!1,null,null,null);s.default=v.exports}}]);